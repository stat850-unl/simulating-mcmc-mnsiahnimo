---
title: "Monte Carlo Simulation"
author: "Michael Nsiah-Nimo"
format: html
---


(Adapted from Monte Carlo Simulation: An Introduction for Engineers and Scientists by Alan Stevens, Chapter 11)

Polymers are large molecules comprised of a large number of repeated units (monomers) linked end to end. 
There are naturally occurring polymers, such as cellulose, and artificial polymers, such as polythene (polyethylene). 
A simple model of a polymer assumes its linked units are each oriented completely randomly with respect to each other. 
This results in a nearly infinite number of configurations.

Suppose the goal is to estimate the straight-line distance between the start and end of the polymer chain. 
The theoretical probability density function for this distance is $$P(R) = 4\pi R^2\left(\frac{3}{2\pi\langle r^2\rangle}\right)^{3/2}\exp\left(-\frac{3R^2}{2\langle r^2\rangle}\right), $$
where $R$ is the end-to-end distance, and the mean square position of the units is $\langle r^2\rangle = N u^2$ where $N$ is the number of units in the chain and $u$ is ithe length of each unit. 
For simplicity, we'll work with $u=1$. 


# Unconstrained Polymer Chains

The position of each link of the chain relative to the previous link can be described with angles $\theta\in[0,2\pi]$ and $\phi\in[0,pi]$ (think of $\theta$ as describing the direction in the XY plane and $\phi$ as describing the direction in the plane uniquely defined by the points $(0,0,0)$, $(x, y, 0)$, and $(x, y, z)$). In this case, $\phi$ need only cover $\pi$ radians. 

Without loss of generality, we can assume that the chain starts at the origin. 
Then, the end point in the chain can be described by a cumulative sum of a series of x, y, and z coordinates that are a function of $\theta_{n\times 1}$ and $\phi_{n\times 1}$:

$$\begin{array}{rcl} x &=& \cos(\theta)\sin(\phi)\\
y &=& \sin(\theta)\sin(\phi)\\
z &=& \cos(\phi)\end{array} $$

The distance between the origin and the end of the chain $(x,y,z)$ can be calculated as $\sqrt{x^2 + y^2 + z^2}$. 


## Single Unconstrained Link Function

Write a function that takes $n$ and returns the distance between the start and end points of a chain. 
Use vector-based operations to increase the efficiency of your function.

```{r}
unconstrained_chain <- function(n) {
  # angles
  theta <- runif(n, 0, 2*pi)
  phi   <- runif(n, 0, pi)
  
  # components
  x <- cos(theta) * sin(phi)
  y <- sin(theta) * sin(phi)
  z <- cos(phi)
  
  # end-to-end distance
  R <- sqrt((sum(x))^2 + (sum(y))^2 + (sum(z))^2)
  return(R)
}
```


## Distribution of Unconstrained Links

Simulate 10000 chains and save the distribution of the end-to-end distance.

```{r}

set.seed(7292)
N_sim <- 10000
n_links <- 50  # or whatever value assigned

R_unconstrained <- replicate(N_sim, unconstrained_chain(n_links))

```



# Constrained Polymer Chains
For real polymers, adjacent links don’t have the complete freedom of orientation allowed in the case of the ideal model. 
We can simulate a simple constrained orientation model by restricting the relative orientation of adjacent links.
We’ll prevent adjacent links from orienting themselves such that there is an acute angle smaller than, say 45° between them. 
We can do this by checking the angle between adjacent links after choosing a random orientation and repeatedly choosing the random orientation until that angle is larger than 45°.


## Single Constrained Link Function

Write a function that takes $n$ and returns the distance between the start and end points of a chain. 
Can you think of a way to use vectorized functions to accomplish this task? Why or why not? 

- **Vectorization won’t work here** because each new link depends on the direction of the link before it. We have to check the angle and redraw until it meets the 45° rule, so each step must be done one at a time. Since the steps aren’t independent, a loop is required

```{r}
constrained_chain <- function(n) {
  # First link direction
  theta <- runif(1, 0, 2*pi)
  phi   <- runif(1, 0, pi)
  
  prev_vec <- c(cos(theta)*sin(phi),
                sin(theta)*sin(phi),
                cos(phi))
  
  X <- prev_vec
  
  for (i in 2:n) {
    repeat {
      # generate trial direction
      theta <- runif(1, 0, 2*pi)
      phi   <- runif(1, 0, pi)
      
      new_vec <- c(cos(theta)*sin(phi),
                   sin(theta)*sin(phi),
                   cos(phi))
      
      # angle between prev_vec and new_vec
      angle <- acos(sum(prev_vec * new_vec))  # dot product
      
      if (angle >= pi/4) {   # 45 degrees
        break
      }
    }
    
    # new_vec
    X <- rbind(X, new_vec)
    prev_vec <- new_vec
  }
  
  # compute R
  end_point <- colSums(X)
  R <- sqrt(sum(end_point^2))
  return(R)
}
```


## Distribution of Constrained Links

Simulate 10000 chains and save the distribution of the end-to-end distance.
Plot the density of the unconstrained links and the density of constrained links on the same plot -- how much has the distribution changed?

```{r}
set.seed(7292)
R_constrained <- replicate(N_sim, constrained_chain(n_links))

```

## Plot 

```{r}
library(ggplot2)

df <- data.frame(
  R = c(R_unconstrained, R_constrained),
  type = rep(c("Unconstrained", "Constrained"),
             each = length(R_unconstrained))
)

ggplot(df, aes(R, color = type)) +
  geom_density(size = 1.1) +
  labs(title = "End-to-End Distance: Constrained vs Unconstrained Polymers",
       x = "Distance R",
       y = "Density") +
  theme_minimal()

```


- We see a clear shift in the distribution of the end-to-end distance. The constrained chains have larger average end-to-end distance and a more concentrated density, while the unconstrained chains have shorter distances and a broader spread. The 45° constraint makes the chain effectively stiffer and less able to fold back on itself, so the polymer ends up further from the origin.



